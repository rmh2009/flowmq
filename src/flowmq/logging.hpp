#pragma once

#include <string>
#include <iostream>
#include <fstream>
#include <thread>
#include <chrono>

namespace flowmq{

// A simple macro based logging module using 
// the stream style logging.

// mutex guarded output object, this is thread safe.
// Do not use directly, this is generated by Logger class.
class LoggerOutput{
    public:
        LoggerOutput(std::ostream& out, std::mutex& mutex):
            ostream_(out),
            lock_(mutex)
    {}

        template<class T>
            std::ostream& operator<<(T&& x){
                ostream_ << std::forward<T>(x);
                return ostream_;
            }
    private:
        std::ostream& ostream_;
        std::unique_lock<std::mutex> lock_;
};

// Logger class, used as a singleton.
// If no file output is set using open_logger(), will default 
// to write to std::cout.
class Logger {
    public:
        Logger():
            file_is_set_(false)
    {
    }

        ~Logger(){
            ofstream_.close();
        }

        void open_logger(const std::string& file_name){
            ofstream_.open(file_name, std::ios_base::out);
            if(!ofstream_.is_open()){
                throw std::runtime_error("Unable to open logger with file " + file_name);
            }
            file_is_set_ = true;
        }

        static Logger& get_logger(){
            // c++11 guarantees the thread safety of static singleton 
            // so we don't need locks.
            static Logger logger;
            return logger;
        }

        static std::string get_time()
        {
            auto now = std::chrono::system_clock::now();

            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
            time_t raw_time = std::chrono::system_clock::to_time_t(now);
            std::string time_str = ctime( &raw_time );
            return time_str.substr(0, time_str.size() - 1 ) + ':' + std::to_string(ms.count());
        }

        // returns the guarded output
        LoggerOutput get_output(){
            if(!file_is_set_) return LoggerOutput(std::cout, mutex_);
            return LoggerOutput(ofstream_, mutex_);
        }

    private:
        bool file_is_set_;
        std::mutex mutex_;
        std::ofstream ofstream_;
};

#define FLOWMQ_OUTPUT_FILE(x) \
    flowmq::Logger::get_logger().open_logger(x);

#ifdef FLOWMQ_LOG_LEVEL_2
const bool logging_debug_disabled__ = false;
const bool logging_info_disabled__  = false;
const bool logging_error_disabled__ = false;
#else 
#ifdef FLOWMQ_LOG_LEVEL_1
const bool logging_debug_disabled__ = true;
const bool logging_info_disabled__  = false;
const bool logging_error_disabled__ = false;
#else  //default output error only
const bool logging_debug_disabled__ = true;
const bool logging_info_disabled__  = true;
const bool logging_error_disabled__ = false;
#endif
#endif

#define LOG_DEBUG  \
    if(flowmq::logging_debug_disabled__){} else \
flowmq::Logger::get_logger().get_output() << "\n" << flowmq::Logger::get_time() << " thread " << std::this_thread::get_id() << ' ' << __FILE__ << ' ' << __LINE__ << " DEBUG: "

#define LOG_INFO  \
    if(flowmq::logging_info_disabled__){} else \
flowmq::Logger::get_logger().get_output() << "\n" << flowmq::Logger::get_time() << " thread " << std::this_thread::get_id() << ' ' << __FILE__ << ' ' << __LINE__ << " INFO: "

#define LOG_ERROR \
    if(flowmq::logging_error_disabled__){} else \
flowmq::Logger::get_logger().get_output() << "\n" << flowmq::Logger::get_time() << " thread " << std::this_thread::get_id() << ' ' <<__FILE__ << ' ' << __LINE__ << " ERROR: " 


}
