// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flow_message.proto

#ifndef PROTOBUF_INCLUDED_flow_5fmessage_2eproto
#define PROTOBUF_INCLUDED_flow_5fmessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_flow_5fmessage_2eproto 

namespace protobuf_flow_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_flow_5fmessage_2eproto
namespace flowmq {
class FlowMessage;
class FlowMessageDefaultTypeInternal;
extern FlowMessageDefaultTypeInternal _FlowMessage_default_instance_;
class FlowMessage_AppendEntriesRequest;
class FlowMessage_AppendEntriesRequestDefaultTypeInternal;
extern FlowMessage_AppendEntriesRequestDefaultTypeInternal _FlowMessage_AppendEntriesRequest_default_instance_;
class FlowMessage_AppendEntriesResponse;
class FlowMessage_AppendEntriesResponseDefaultTypeInternal;
extern FlowMessage_AppendEntriesResponseDefaultTypeInternal _FlowMessage_AppendEntriesResponse_default_instance_;
class FlowMessage_ClientCommitMessage;
class FlowMessage_ClientCommitMessageDefaultTypeInternal;
extern FlowMessage_ClientCommitMessageDefaultTypeInternal _FlowMessage_ClientCommitMessage_default_instance_;
class FlowMessage_ClientOpenQueue;
class FlowMessage_ClientOpenQueueDefaultTypeInternal;
extern FlowMessage_ClientOpenQueueDefaultTypeInternal _FlowMessage_ClientOpenQueue_default_instance_;
class FlowMessage_ClientOpenQueueResponse;
class FlowMessage_ClientOpenQueueResponseDefaultTypeInternal;
extern FlowMessage_ClientOpenQueueResponseDefaultTypeInternal _FlowMessage_ClientOpenQueueResponse_default_instance_;
class FlowMessage_ClientPutMessage;
class FlowMessage_ClientPutMessageDefaultTypeInternal;
extern FlowMessage_ClientPutMessageDefaultTypeInternal _FlowMessage_ClientPutMessage_default_instance_;
class FlowMessage_ClientPutMessageResponse;
class FlowMessage_ClientPutMessageResponseDefaultTypeInternal;
extern FlowMessage_ClientPutMessageResponseDefaultTypeInternal _FlowMessage_ClientPutMessageResponse_default_instance_;
class FlowMessage_ConsumerDisconnected;
class FlowMessage_ConsumerDisconnectedDefaultTypeInternal;
extern FlowMessage_ConsumerDisconnectedDefaultTypeInternal _FlowMessage_ConsumerDisconnected_default_instance_;
class FlowMessage_RequestVoteRequest;
class FlowMessage_RequestVoteRequestDefaultTypeInternal;
extern FlowMessage_RequestVoteRequestDefaultTypeInternal _FlowMessage_RequestVoteRequest_default_instance_;
class FlowMessage_RequestVoteResponse;
class FlowMessage_RequestVoteResponseDefaultTypeInternal;
extern FlowMessage_RequestVoteResponseDefaultTypeInternal _FlowMessage_RequestVoteResponse_default_instance_;
class FlowMessage_ServerSendMessage;
class FlowMessage_ServerSendMessageDefaultTypeInternal;
extern FlowMessage_ServerSendMessageDefaultTypeInternal _FlowMessage_ServerSendMessage_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
}  // namespace flowmq
namespace google {
namespace protobuf {
template<> ::flowmq::FlowMessage* Arena::CreateMaybeMessage<::flowmq::FlowMessage>(Arena*);
template<> ::flowmq::FlowMessage_AppendEntriesRequest* Arena::CreateMaybeMessage<::flowmq::FlowMessage_AppendEntriesRequest>(Arena*);
template<> ::flowmq::FlowMessage_AppendEntriesResponse* Arena::CreateMaybeMessage<::flowmq::FlowMessage_AppendEntriesResponse>(Arena*);
template<> ::flowmq::FlowMessage_ClientCommitMessage* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ClientCommitMessage>(Arena*);
template<> ::flowmq::FlowMessage_ClientOpenQueue* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ClientOpenQueue>(Arena*);
template<> ::flowmq::FlowMessage_ClientOpenQueueResponse* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ClientOpenQueueResponse>(Arena*);
template<> ::flowmq::FlowMessage_ClientPutMessage* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ClientPutMessage>(Arena*);
template<> ::flowmq::FlowMessage_ClientPutMessageResponse* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ClientPutMessageResponse>(Arena*);
template<> ::flowmq::FlowMessage_ConsumerDisconnected* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ConsumerDisconnected>(Arena*);
template<> ::flowmq::FlowMessage_RequestVoteRequest* Arena::CreateMaybeMessage<::flowmq::FlowMessage_RequestVoteRequest>(Arena*);
template<> ::flowmq::FlowMessage_RequestVoteResponse* Arena::CreateMaybeMessage<::flowmq::FlowMessage_RequestVoteResponse>(Arena*);
template<> ::flowmq::FlowMessage_ServerSendMessage* Arena::CreateMaybeMessage<::flowmq::FlowMessage_ServerSendMessage>(Arena*);
template<> ::flowmq::LogEntry* Arena::CreateMaybeMessage<::flowmq::LogEntry>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flowmq {

enum LogEntry_OPERATION {
  LogEntry_OPERATION_ADD = 0,
  LogEntry_OPERATION_COMMIT = 1
};
bool LogEntry_OPERATION_IsValid(int value);
const LogEntry_OPERATION LogEntry_OPERATION_OPERATION_MIN = LogEntry_OPERATION_ADD;
const LogEntry_OPERATION LogEntry_OPERATION_OPERATION_MAX = LogEntry_OPERATION_COMMIT;
const int LogEntry_OPERATION_OPERATION_ARRAYSIZE = LogEntry_OPERATION_OPERATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogEntry_OPERATION_descriptor();
inline const ::std::string& LogEntry_OPERATION_Name(LogEntry_OPERATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogEntry_OPERATION_descriptor(), value);
}
inline bool LogEntry_OPERATION_Parse(
    const ::std::string& name, LogEntry_OPERATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEntry_OPERATION>(
    LogEntry_OPERATION_descriptor(), name, value);
}
enum FlowMessage_MessageType {
  FlowMessage_MessageType_REQUEST_VOTE_REQUEST = 0,
  FlowMessage_MessageType_REQUEST_VOTE_RESPONSE = 1,
  FlowMessage_MessageType_APPEND_ENTRIES_REQUEST = 2,
  FlowMessage_MessageType_APPEND_ENTRIES_RESPONSE = 3,
  FlowMessage_MessageType_CLIENT_PUT_MESSAGE = 10,
  FlowMessage_MessageType_CLIENT_COMMIT_MESSAGE = 11,
  FlowMessage_MessageType_SERVER_SEND_MESSAGE = 12,
  FlowMessage_MessageType_CLIENT_OPEN_QUEUE = 13,
  FlowMessage_MessageType_CONSUMER_DISCONNECTED = 14,
  FlowMessage_MessageType_CLIENT_PUT_MESSAGE_RESPONSE = 15,
  FlowMessage_MessageType_CLIENT_OPEN_QUEUE_RESPONSE = 16,
  FlowMessage_MessageType_UNKNOWN = 99
};
bool FlowMessage_MessageType_IsValid(int value);
const FlowMessage_MessageType FlowMessage_MessageType_MessageType_MIN = FlowMessage_MessageType_REQUEST_VOTE_REQUEST;
const FlowMessage_MessageType FlowMessage_MessageType_MessageType_MAX = FlowMessage_MessageType_UNKNOWN;
const int FlowMessage_MessageType_MessageType_ARRAYSIZE = FlowMessage_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FlowMessage_MessageType_descriptor();
inline const ::std::string& FlowMessage_MessageType_Name(FlowMessage_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FlowMessage_MessageType_descriptor(), value);
}
inline bool FlowMessage_MessageType_Parse(
    const ::std::string& name, FlowMessage_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlowMessage_MessageType>(
    FlowMessage_MessageType_descriptor(), name, value);
}
enum FlowMessage_Status {
  FlowMessage_Status_SUCCESS = 0,
  FlowMessage_Status_ERROR = 1
};
bool FlowMessage_Status_IsValid(int value);
const FlowMessage_Status FlowMessage_Status_Status_MIN = FlowMessage_Status_SUCCESS;
const FlowMessage_Status FlowMessage_Status_Status_MAX = FlowMessage_Status_ERROR;
const int FlowMessage_Status_Status_ARRAYSIZE = FlowMessage_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* FlowMessage_Status_descriptor();
inline const ::std::string& FlowMessage_Status_Name(FlowMessage_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    FlowMessage_Status_descriptor(), value);
}
inline bool FlowMessage_Status_Parse(
    const ::std::string& name, FlowMessage_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlowMessage_Status>(
    FlowMessage_Status_descriptor(), name, value);
}
// ===================================================================

class LogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const final {
    return CreateMaybeMessage<LogEntry>(NULL);
  }

  LogEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogEntry_OPERATION OPERATION;
  static const OPERATION ADD =
    LogEntry_OPERATION_ADD;
  static const OPERATION COMMIT =
    LogEntry_OPERATION_COMMIT;
  static inline bool OPERATION_IsValid(int value) {
    return LogEntry_OPERATION_IsValid(value);
  }
  static const OPERATION OPERATION_MIN =
    LogEntry_OPERATION_OPERATION_MIN;
  static const OPERATION OPERATION_MAX =
    LogEntry_OPERATION_OPERATION_MAX;
  static const int OPERATION_ARRAYSIZE =
    LogEntry_OPERATION_OPERATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATION_descriptor() {
    return LogEntry_OPERATION_descriptor();
  }
  static inline const ::std::string& OPERATION_Name(OPERATION value) {
    return LogEntry_OPERATION_Name(value);
  }
  static inline bool OPERATION_Parse(const ::std::string& name,
      OPERATION* value) {
    return LogEntry_OPERATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // required int32 term = 2;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 2;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // required int64 message_id = 3;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  ::google::protobuf::int64 message_id() const;
  void set_message_id(::google::protobuf::int64 value);

  // required int32 operation = 4;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 4;
  ::google::protobuf::int32 operation() const;
  void set_operation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.LogEntry)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_term();
  void clear_has_term();
  void set_has_message_id();
  void clear_has_message_id();
  void set_has_operation();
  void clear_has_operation();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int64 message_id_;
  ::google::protobuf::int32 operation_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_RequestVoteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.RequestVoteRequest) */ {
 public:
  FlowMessage_RequestVoteRequest();
  virtual ~FlowMessage_RequestVoteRequest();

  FlowMessage_RequestVoteRequest(const FlowMessage_RequestVoteRequest& from);

  inline FlowMessage_RequestVoteRequest& operator=(const FlowMessage_RequestVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_RequestVoteRequest(FlowMessage_RequestVoteRequest&& from) noexcept
    : FlowMessage_RequestVoteRequest() {
    *this = ::std::move(from);
  }

  inline FlowMessage_RequestVoteRequest& operator=(FlowMessage_RequestVoteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_RequestVoteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_RequestVoteRequest* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_RequestVoteRequest*>(
               &_FlowMessage_RequestVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FlowMessage_RequestVoteRequest* other);
  friend void swap(FlowMessage_RequestVoteRequest& a, FlowMessage_RequestVoteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_RequestVoteRequest* New() const final {
    return CreateMaybeMessage<FlowMessage_RequestVoteRequest>(NULL);
  }

  FlowMessage_RequestVoteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_RequestVoteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_RequestVoteRequest& from);
  void MergeFrom(const FlowMessage_RequestVoteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_RequestVoteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // required int32 candidate_id = 2;
  bool has_candidate_id() const;
  void clear_candidate_id();
  static const int kCandidateIdFieldNumber = 2;
  ::google::protobuf::int32 candidate_id() const;
  void set_candidate_id(::google::protobuf::int32 value);

  // required int32 last_log_index = 3;
  bool has_last_log_index() const;
  void clear_last_log_index();
  static const int kLastLogIndexFieldNumber = 3;
  ::google::protobuf::int32 last_log_index() const;
  void set_last_log_index(::google::protobuf::int32 value);

  // required int32 last_log_term = 4;
  bool has_last_log_term() const;
  void clear_last_log_term();
  static const int kLastLogTermFieldNumber = 4;
  ::google::protobuf::int32 last_log_term() const;
  void set_last_log_term(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.RequestVoteRequest)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_candidate_id();
  void clear_has_candidate_id();
  void set_has_last_log_index();
  void clear_has_last_log_index();
  void set_has_last_log_term();
  void clear_has_last_log_term();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 candidate_id_;
  ::google::protobuf::int32 last_log_index_;
  ::google::protobuf::int32 last_log_term_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_RequestVoteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.RequestVoteResponse) */ {
 public:
  FlowMessage_RequestVoteResponse();
  virtual ~FlowMessage_RequestVoteResponse();

  FlowMessage_RequestVoteResponse(const FlowMessage_RequestVoteResponse& from);

  inline FlowMessage_RequestVoteResponse& operator=(const FlowMessage_RequestVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_RequestVoteResponse(FlowMessage_RequestVoteResponse&& from) noexcept
    : FlowMessage_RequestVoteResponse() {
    *this = ::std::move(from);
  }

  inline FlowMessage_RequestVoteResponse& operator=(FlowMessage_RequestVoteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_RequestVoteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_RequestVoteResponse* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_RequestVoteResponse*>(
               &_FlowMessage_RequestVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FlowMessage_RequestVoteResponse* other);
  friend void swap(FlowMessage_RequestVoteResponse& a, FlowMessage_RequestVoteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_RequestVoteResponse* New() const final {
    return CreateMaybeMessage<FlowMessage_RequestVoteResponse>(NULL);
  }

  FlowMessage_RequestVoteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_RequestVoteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_RequestVoteResponse& from);
  void MergeFrom(const FlowMessage_RequestVoteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_RequestVoteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // required int32 vote_result_term_granted = 2;
  bool has_vote_result_term_granted() const;
  void clear_vote_result_term_granted();
  static const int kVoteResultTermGrantedFieldNumber = 2;
  ::google::protobuf::int32 vote_result_term_granted() const;
  void set_vote_result_term_granted(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.RequestVoteResponse)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_vote_result_term_granted();
  void clear_has_vote_result_term_granted();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 vote_result_term_granted_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_AppendEntriesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.AppendEntriesRequest) */ {
 public:
  FlowMessage_AppendEntriesRequest();
  virtual ~FlowMessage_AppendEntriesRequest();

  FlowMessage_AppendEntriesRequest(const FlowMessage_AppendEntriesRequest& from);

  inline FlowMessage_AppendEntriesRequest& operator=(const FlowMessage_AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_AppendEntriesRequest(FlowMessage_AppendEntriesRequest&& from) noexcept
    : FlowMessage_AppendEntriesRequest() {
    *this = ::std::move(from);
  }

  inline FlowMessage_AppendEntriesRequest& operator=(FlowMessage_AppendEntriesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_AppendEntriesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_AppendEntriesRequest* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_AppendEntriesRequest*>(
               &_FlowMessage_AppendEntriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FlowMessage_AppendEntriesRequest* other);
  friend void swap(FlowMessage_AppendEntriesRequest& a, FlowMessage_AppendEntriesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_AppendEntriesRequest* New() const final {
    return CreateMaybeMessage<FlowMessage_AppendEntriesRequest>(NULL);
  }

  FlowMessage_AppendEntriesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_AppendEntriesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_AppendEntriesRequest& from);
  void MergeFrom(const FlowMessage_AppendEntriesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_AppendEntriesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flowmq.LogEntry entries = 5;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 5;
  ::flowmq::LogEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::flowmq::LogEntry >*
      mutable_entries();
  const ::flowmq::LogEntry& entries(int index) const;
  ::flowmq::LogEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::flowmq::LogEntry >&
      entries() const;

  // required int32 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // required int32 leader_id = 2;
  bool has_leader_id() const;
  void clear_leader_id();
  static const int kLeaderIdFieldNumber = 2;
  ::google::protobuf::int32 leader_id() const;
  void set_leader_id(::google::protobuf::int32 value);

  // required int32 prev_log_index = 3;
  bool has_prev_log_index() const;
  void clear_prev_log_index();
  static const int kPrevLogIndexFieldNumber = 3;
  ::google::protobuf::int32 prev_log_index() const;
  void set_prev_log_index(::google::protobuf::int32 value);

  // required int32 prev_log_term = 4;
  bool has_prev_log_term() const;
  void clear_prev_log_term();
  static const int kPrevLogTermFieldNumber = 4;
  ::google::protobuf::int32 prev_log_term() const;
  void set_prev_log_term(::google::protobuf::int32 value);

  // required int32 leader_commit = 6;
  bool has_leader_commit() const;
  void clear_leader_commit();
  static const int kLeaderCommitFieldNumber = 6;
  ::google::protobuf::int32 leader_commit() const;
  void set_leader_commit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.AppendEntriesRequest)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_leader_id();
  void clear_has_leader_id();
  void set_has_prev_log_index();
  void clear_has_prev_log_index();
  void set_has_prev_log_term();
  void clear_has_prev_log_term();
  void set_has_leader_commit();
  void clear_has_leader_commit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::flowmq::LogEntry > entries_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 leader_id_;
  ::google::protobuf::int32 prev_log_index_;
  ::google::protobuf::int32 prev_log_term_;
  ::google::protobuf::int32 leader_commit_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_AppendEntriesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.AppendEntriesResponse) */ {
 public:
  FlowMessage_AppendEntriesResponse();
  virtual ~FlowMessage_AppendEntriesResponse();

  FlowMessage_AppendEntriesResponse(const FlowMessage_AppendEntriesResponse& from);

  inline FlowMessage_AppendEntriesResponse& operator=(const FlowMessage_AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_AppendEntriesResponse(FlowMessage_AppendEntriesResponse&& from) noexcept
    : FlowMessage_AppendEntriesResponse() {
    *this = ::std::move(from);
  }

  inline FlowMessage_AppendEntriesResponse& operator=(FlowMessage_AppendEntriesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_AppendEntriesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_AppendEntriesResponse* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_AppendEntriesResponse*>(
               &_FlowMessage_AppendEntriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FlowMessage_AppendEntriesResponse* other);
  friend void swap(FlowMessage_AppendEntriesResponse& a, FlowMessage_AppendEntriesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_AppendEntriesResponse* New() const final {
    return CreateMaybeMessage<FlowMessage_AppendEntriesResponse>(NULL);
  }

  FlowMessage_AppendEntriesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_AppendEntriesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_AppendEntriesResponse& from);
  void MergeFrom(const FlowMessage_AppendEntriesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_AppendEntriesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 term = 1;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // required int32 follower_id = 2;
  bool has_follower_id() const;
  void clear_follower_id();
  static const int kFollowerIdFieldNumber = 2;
  ::google::protobuf::int32 follower_id() const;
  void set_follower_id(::google::protobuf::int32 value);

  // required int32 append_result_success = 3;
  bool has_append_result_success() const;
  void clear_append_result_success();
  static const int kAppendResultSuccessFieldNumber = 3;
  ::google::protobuf::int32 append_result_success() const;
  void set_append_result_success(::google::protobuf::int32 value);

  // required int32 last_index_synced = 4;
  bool has_last_index_synced() const;
  void clear_last_index_synced();
  static const int kLastIndexSyncedFieldNumber = 4;
  ::google::protobuf::int32 last_index_synced() const;
  void set_last_index_synced(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.AppendEntriesResponse)
 private:
  void set_has_term();
  void clear_has_term();
  void set_has_follower_id();
  void clear_has_follower_id();
  void set_has_append_result_success();
  void clear_has_append_result_success();
  void set_has_last_index_synced();
  void clear_has_last_index_synced();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 follower_id_;
  ::google::protobuf::int32 append_result_success_;
  ::google::protobuf::int32 last_index_synced_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ClientPutMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ClientPutMessage) */ {
 public:
  FlowMessage_ClientPutMessage();
  virtual ~FlowMessage_ClientPutMessage();

  FlowMessage_ClientPutMessage(const FlowMessage_ClientPutMessage& from);

  inline FlowMessage_ClientPutMessage& operator=(const FlowMessage_ClientPutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ClientPutMessage(FlowMessage_ClientPutMessage&& from) noexcept
    : FlowMessage_ClientPutMessage() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ClientPutMessage& operator=(FlowMessage_ClientPutMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ClientPutMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ClientPutMessage* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ClientPutMessage*>(
               &_FlowMessage_ClientPutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FlowMessage_ClientPutMessage* other);
  friend void swap(FlowMessage_ClientPutMessage& a, FlowMessage_ClientPutMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ClientPutMessage* New() const final {
    return CreateMaybeMessage<FlowMessage_ClientPutMessage>(NULL);
  }

  FlowMessage_ClientPutMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ClientPutMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ClientPutMessage& from);
  void MergeFrom(const FlowMessage_ClientPutMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ClientPutMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int64 message_id = 2;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  ::google::protobuf::int64 message_id() const;
  void set_message_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ClientPutMessage)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_message_id();
  void clear_has_message_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int64 message_id_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ClientPutMessageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ClientPutMessageResponse) */ {
 public:
  FlowMessage_ClientPutMessageResponse();
  virtual ~FlowMessage_ClientPutMessageResponse();

  FlowMessage_ClientPutMessageResponse(const FlowMessage_ClientPutMessageResponse& from);

  inline FlowMessage_ClientPutMessageResponse& operator=(const FlowMessage_ClientPutMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ClientPutMessageResponse(FlowMessage_ClientPutMessageResponse&& from) noexcept
    : FlowMessage_ClientPutMessageResponse() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ClientPutMessageResponse& operator=(FlowMessage_ClientPutMessageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ClientPutMessageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ClientPutMessageResponse* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ClientPutMessageResponse*>(
               &_FlowMessage_ClientPutMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FlowMessage_ClientPutMessageResponse* other);
  friend void swap(FlowMessage_ClientPutMessageResponse& a, FlowMessage_ClientPutMessageResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ClientPutMessageResponse* New() const final {
    return CreateMaybeMessage<FlowMessage_ClientPutMessageResponse>(NULL);
  }

  FlowMessage_ClientPutMessageResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ClientPutMessageResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ClientPutMessageResponse& from);
  void MergeFrom(const FlowMessage_ClientPutMessageResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ClientPutMessageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error_message = 3;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // required int64 message_id = 1;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  ::google::protobuf::int64 message_id() const;
  void set_message_id(::google::protobuf::int64 value);

  // required .flowmq.FlowMessage.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::flowmq::FlowMessage_Status status() const;
  void set_status(::flowmq::FlowMessage_Status value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ClientPutMessageResponse)
 private:
  void set_has_message_id();
  void clear_has_message_id();
  void set_has_status();
  void clear_has_status();
  void set_has_error_message();
  void clear_has_error_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::int64 message_id_;
  int status_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ClientCommitMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ClientCommitMessage) */ {
 public:
  FlowMessage_ClientCommitMessage();
  virtual ~FlowMessage_ClientCommitMessage();

  FlowMessage_ClientCommitMessage(const FlowMessage_ClientCommitMessage& from);

  inline FlowMessage_ClientCommitMessage& operator=(const FlowMessage_ClientCommitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ClientCommitMessage(FlowMessage_ClientCommitMessage&& from) noexcept
    : FlowMessage_ClientCommitMessage() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ClientCommitMessage& operator=(FlowMessage_ClientCommitMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ClientCommitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ClientCommitMessage* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ClientCommitMessage*>(
               &_FlowMessage_ClientCommitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FlowMessage_ClientCommitMessage* other);
  friend void swap(FlowMessage_ClientCommitMessage& a, FlowMessage_ClientCommitMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ClientCommitMessage* New() const final {
    return CreateMaybeMessage<FlowMessage_ClientCommitMessage>(NULL);
  }

  FlowMessage_ClientCommitMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ClientCommitMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ClientCommitMessage& from);
  void MergeFrom(const FlowMessage_ClientCommitMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ClientCommitMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 message_id = 1;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  ::google::protobuf::int64 message_id() const;
  void set_message_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ClientCommitMessage)
 private:
  void set_has_message_id();
  void clear_has_message_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 message_id_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ServerSendMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ServerSendMessage) */ {
 public:
  FlowMessage_ServerSendMessage();
  virtual ~FlowMessage_ServerSendMessage();

  FlowMessage_ServerSendMessage(const FlowMessage_ServerSendMessage& from);

  inline FlowMessage_ServerSendMessage& operator=(const FlowMessage_ServerSendMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ServerSendMessage(FlowMessage_ServerSendMessage&& from) noexcept
    : FlowMessage_ServerSendMessage() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ServerSendMessage& operator=(FlowMessage_ServerSendMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ServerSendMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ServerSendMessage* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ServerSendMessage*>(
               &_FlowMessage_ServerSendMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(FlowMessage_ServerSendMessage* other);
  friend void swap(FlowMessage_ServerSendMessage& a, FlowMessage_ServerSendMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ServerSendMessage* New() const final {
    return CreateMaybeMessage<FlowMessage_ServerSendMessage>(NULL);
  }

  FlowMessage_ServerSendMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ServerSendMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ServerSendMessage& from);
  void MergeFrom(const FlowMessage_ServerSendMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ServerSendMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int64 message_id = 1;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  ::google::protobuf::int64 message_id() const;
  void set_message_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ServerSendMessage)
 private:
  void set_has_message_id();
  void clear_has_message_id();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int64 message_id_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ClientOpenQueue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ClientOpenQueue) */ {
 public:
  FlowMessage_ClientOpenQueue();
  virtual ~FlowMessage_ClientOpenQueue();

  FlowMessage_ClientOpenQueue(const FlowMessage_ClientOpenQueue& from);

  inline FlowMessage_ClientOpenQueue& operator=(const FlowMessage_ClientOpenQueue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ClientOpenQueue(FlowMessage_ClientOpenQueue&& from) noexcept
    : FlowMessage_ClientOpenQueue() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ClientOpenQueue& operator=(FlowMessage_ClientOpenQueue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ClientOpenQueue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ClientOpenQueue* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ClientOpenQueue*>(
               &_FlowMessage_ClientOpenQueue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FlowMessage_ClientOpenQueue* other);
  friend void swap(FlowMessage_ClientOpenQueue& a, FlowMessage_ClientOpenQueue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ClientOpenQueue* New() const final {
    return CreateMaybeMessage<FlowMessage_ClientOpenQueue>(NULL);
  }

  FlowMessage_ClientOpenQueue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ClientOpenQueue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ClientOpenQueue& from);
  void MergeFrom(const FlowMessage_ClientOpenQueue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ClientOpenQueue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string queue_name = 2;
  bool has_queue_name() const;
  void clear_queue_name();
  static const int kQueueNameFieldNumber = 2;
  const ::std::string& queue_name() const;
  void set_queue_name(const ::std::string& value);
  #if LANG_CXX11
  void set_queue_name(::std::string&& value);
  #endif
  void set_queue_name(const char* value);
  void set_queue_name(const char* value, size_t size);
  ::std::string* mutable_queue_name();
  ::std::string* release_queue_name();
  void set_allocated_queue_name(::std::string* queue_name);

  // required int32 open_mode = 1;
  bool has_open_mode() const;
  void clear_open_mode();
  static const int kOpenModeFieldNumber = 1;
  ::google::protobuf::int32 open_mode() const;
  void set_open_mode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ClientOpenQueue)
 private:
  void set_has_open_mode();
  void clear_has_open_mode();
  void set_has_queue_name();
  void clear_has_queue_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr queue_name_;
  ::google::protobuf::int32 open_mode_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ClientOpenQueueResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ClientOpenQueueResponse) */ {
 public:
  FlowMessage_ClientOpenQueueResponse();
  virtual ~FlowMessage_ClientOpenQueueResponse();

  FlowMessage_ClientOpenQueueResponse(const FlowMessage_ClientOpenQueueResponse& from);

  inline FlowMessage_ClientOpenQueueResponse& operator=(const FlowMessage_ClientOpenQueueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ClientOpenQueueResponse(FlowMessage_ClientOpenQueueResponse&& from) noexcept
    : FlowMessage_ClientOpenQueueResponse() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ClientOpenQueueResponse& operator=(FlowMessage_ClientOpenQueueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ClientOpenQueueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ClientOpenQueueResponse* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ClientOpenQueueResponse*>(
               &_FlowMessage_ClientOpenQueueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FlowMessage_ClientOpenQueueResponse* other);
  friend void swap(FlowMessage_ClientOpenQueueResponse& a, FlowMessage_ClientOpenQueueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ClientOpenQueueResponse* New() const final {
    return CreateMaybeMessage<FlowMessage_ClientOpenQueueResponse>(NULL);
  }

  FlowMessage_ClientOpenQueueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ClientOpenQueueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ClientOpenQueueResponse& from);
  void MergeFrom(const FlowMessage_ClientOpenQueueResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ClientOpenQueueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error_message = 2;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // optional string leader_ip = 3;
  bool has_leader_ip() const;
  void clear_leader_ip();
  static const int kLeaderIpFieldNumber = 3;
  const ::std::string& leader_ip() const;
  void set_leader_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_leader_ip(::std::string&& value);
  #endif
  void set_leader_ip(const char* value);
  void set_leader_ip(const char* value, size_t size);
  ::std::string* mutable_leader_ip();
  ::std::string* release_leader_ip();
  void set_allocated_leader_ip(::std::string* leader_ip);

  // optional string leader_port = 4;
  bool has_leader_port() const;
  void clear_leader_port();
  static const int kLeaderPortFieldNumber = 4;
  const ::std::string& leader_port() const;
  void set_leader_port(const ::std::string& value);
  #if LANG_CXX11
  void set_leader_port(::std::string&& value);
  #endif
  void set_leader_port(const char* value);
  void set_leader_port(const char* value, size_t size);
  ::std::string* mutable_leader_port();
  ::std::string* release_leader_port();
  void set_allocated_leader_port(::std::string* leader_port);

  // required .flowmq.FlowMessage.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::flowmq::FlowMessage_Status status() const;
  void set_status(::flowmq::FlowMessage_Status value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ClientOpenQueueResponse)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_error_message();
  void clear_has_error_message();
  void set_has_leader_ip();
  void clear_has_leader_ip();
  void set_has_leader_port();
  void clear_has_leader_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::internal::ArenaStringPtr leader_ip_;
  ::google::protobuf::internal::ArenaStringPtr leader_port_;
  int status_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage_ConsumerDisconnected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage.ConsumerDisconnected) */ {
 public:
  FlowMessage_ConsumerDisconnected();
  virtual ~FlowMessage_ConsumerDisconnected();

  FlowMessage_ConsumerDisconnected(const FlowMessage_ConsumerDisconnected& from);

  inline FlowMessage_ConsumerDisconnected& operator=(const FlowMessage_ConsumerDisconnected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage_ConsumerDisconnected(FlowMessage_ConsumerDisconnected&& from) noexcept
    : FlowMessage_ConsumerDisconnected() {
    *this = ::std::move(from);
  }

  inline FlowMessage_ConsumerDisconnected& operator=(FlowMessage_ConsumerDisconnected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage_ConsumerDisconnected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage_ConsumerDisconnected* internal_default_instance() {
    return reinterpret_cast<const FlowMessage_ConsumerDisconnected*>(
               &_FlowMessage_ConsumerDisconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FlowMessage_ConsumerDisconnected* other);
  friend void swap(FlowMessage_ConsumerDisconnected& a, FlowMessage_ConsumerDisconnected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage_ConsumerDisconnected* New() const final {
    return CreateMaybeMessage<FlowMessage_ConsumerDisconnected>(NULL);
  }

  FlowMessage_ConsumerDisconnected* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage_ConsumerDisconnected>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage_ConsumerDisconnected& from);
  void MergeFrom(const FlowMessage_ConsumerDisconnected& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage_ConsumerDisconnected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  ::google::protobuf::int32 client_id() const;
  void set_client_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage.ConsumerDisconnected)
 private:
  void set_has_client_id();
  void clear_has_client_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 client_id_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flowmq.FlowMessage) */ {
 public:
  FlowMessage();
  virtual ~FlowMessage();

  FlowMessage(const FlowMessage& from);

  inline FlowMessage& operator=(const FlowMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FlowMessage(FlowMessage&& from) noexcept
    : FlowMessage() {
    *this = ::std::move(from);
  }

  inline FlowMessage& operator=(FlowMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlowMessage* internal_default_instance() {
    return reinterpret_cast<const FlowMessage*>(
               &_FlowMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(FlowMessage* other);
  friend void swap(FlowMessage& a, FlowMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FlowMessage* New() const final {
    return CreateMaybeMessage<FlowMessage>(NULL);
  }

  FlowMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FlowMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FlowMessage& from);
  void MergeFrom(const FlowMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FlowMessage_RequestVoteRequest RequestVoteRequest;
  typedef FlowMessage_RequestVoteResponse RequestVoteResponse;
  typedef FlowMessage_AppendEntriesRequest AppendEntriesRequest;
  typedef FlowMessage_AppendEntriesResponse AppendEntriesResponse;
  typedef FlowMessage_ClientPutMessage ClientPutMessage;
  typedef FlowMessage_ClientPutMessageResponse ClientPutMessageResponse;
  typedef FlowMessage_ClientCommitMessage ClientCommitMessage;
  typedef FlowMessage_ServerSendMessage ServerSendMessage;
  typedef FlowMessage_ClientOpenQueue ClientOpenQueue;
  typedef FlowMessage_ClientOpenQueueResponse ClientOpenQueueResponse;
  typedef FlowMessage_ConsumerDisconnected ConsumerDisconnected;

  typedef FlowMessage_MessageType MessageType;
  static const MessageType REQUEST_VOTE_REQUEST =
    FlowMessage_MessageType_REQUEST_VOTE_REQUEST;
  static const MessageType REQUEST_VOTE_RESPONSE =
    FlowMessage_MessageType_REQUEST_VOTE_RESPONSE;
  static const MessageType APPEND_ENTRIES_REQUEST =
    FlowMessage_MessageType_APPEND_ENTRIES_REQUEST;
  static const MessageType APPEND_ENTRIES_RESPONSE =
    FlowMessage_MessageType_APPEND_ENTRIES_RESPONSE;
  static const MessageType CLIENT_PUT_MESSAGE =
    FlowMessage_MessageType_CLIENT_PUT_MESSAGE;
  static const MessageType CLIENT_COMMIT_MESSAGE =
    FlowMessage_MessageType_CLIENT_COMMIT_MESSAGE;
  static const MessageType SERVER_SEND_MESSAGE =
    FlowMessage_MessageType_SERVER_SEND_MESSAGE;
  static const MessageType CLIENT_OPEN_QUEUE =
    FlowMessage_MessageType_CLIENT_OPEN_QUEUE;
  static const MessageType CONSUMER_DISCONNECTED =
    FlowMessage_MessageType_CONSUMER_DISCONNECTED;
  static const MessageType CLIENT_PUT_MESSAGE_RESPONSE =
    FlowMessage_MessageType_CLIENT_PUT_MESSAGE_RESPONSE;
  static const MessageType CLIENT_OPEN_QUEUE_RESPONSE =
    FlowMessage_MessageType_CLIENT_OPEN_QUEUE_RESPONSE;
  static const MessageType UNKNOWN =
    FlowMessage_MessageType_UNKNOWN;
  static inline bool MessageType_IsValid(int value) {
    return FlowMessage_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    FlowMessage_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    FlowMessage_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    FlowMessage_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return FlowMessage_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return FlowMessage_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return FlowMessage_MessageType_Parse(name, value);
  }

  typedef FlowMessage_Status Status;
  static const Status SUCCESS =
    FlowMessage_Status_SUCCESS;
  static const Status ERROR =
    FlowMessage_Status_ERROR;
  static inline bool Status_IsValid(int value) {
    return FlowMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    FlowMessage_Status_Status_MIN;
  static const Status Status_MAX =
    FlowMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    FlowMessage_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return FlowMessage_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return FlowMessage_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return FlowMessage_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .flowmq.FlowMessage.RequestVoteRequest request_vote_request = 3;
  bool has_request_vote_request() const;
  void clear_request_vote_request();
  static const int kRequestVoteRequestFieldNumber = 3;
  private:
  const ::flowmq::FlowMessage_RequestVoteRequest& _internal_request_vote_request() const;
  public:
  const ::flowmq::FlowMessage_RequestVoteRequest& request_vote_request() const;
  ::flowmq::FlowMessage_RequestVoteRequest* release_request_vote_request();
  ::flowmq::FlowMessage_RequestVoteRequest* mutable_request_vote_request();
  void set_allocated_request_vote_request(::flowmq::FlowMessage_RequestVoteRequest* request_vote_request);

  // optional .flowmq.FlowMessage.RequestVoteResponse request_vote_response = 4;
  bool has_request_vote_response() const;
  void clear_request_vote_response();
  static const int kRequestVoteResponseFieldNumber = 4;
  private:
  const ::flowmq::FlowMessage_RequestVoteResponse& _internal_request_vote_response() const;
  public:
  const ::flowmq::FlowMessage_RequestVoteResponse& request_vote_response() const;
  ::flowmq::FlowMessage_RequestVoteResponse* release_request_vote_response();
  ::flowmq::FlowMessage_RequestVoteResponse* mutable_request_vote_response();
  void set_allocated_request_vote_response(::flowmq::FlowMessage_RequestVoteResponse* request_vote_response);

  // optional .flowmq.FlowMessage.AppendEntriesRequest append_entries_request = 5;
  bool has_append_entries_request() const;
  void clear_append_entries_request();
  static const int kAppendEntriesRequestFieldNumber = 5;
  private:
  const ::flowmq::FlowMessage_AppendEntriesRequest& _internal_append_entries_request() const;
  public:
  const ::flowmq::FlowMessage_AppendEntriesRequest& append_entries_request() const;
  ::flowmq::FlowMessage_AppendEntriesRequest* release_append_entries_request();
  ::flowmq::FlowMessage_AppendEntriesRequest* mutable_append_entries_request();
  void set_allocated_append_entries_request(::flowmq::FlowMessage_AppendEntriesRequest* append_entries_request);

  // optional .flowmq.FlowMessage.AppendEntriesResponse append_entries_response = 6;
  bool has_append_entries_response() const;
  void clear_append_entries_response();
  static const int kAppendEntriesResponseFieldNumber = 6;
  private:
  const ::flowmq::FlowMessage_AppendEntriesResponse& _internal_append_entries_response() const;
  public:
  const ::flowmq::FlowMessage_AppendEntriesResponse& append_entries_response() const;
  ::flowmq::FlowMessage_AppendEntriesResponse* release_append_entries_response();
  ::flowmq::FlowMessage_AppendEntriesResponse* mutable_append_entries_response();
  void set_allocated_append_entries_response(::flowmq::FlowMessage_AppendEntriesResponse* append_entries_response);

  // optional .flowmq.FlowMessage.ClientPutMessage client_put_message = 7;
  bool has_client_put_message() const;
  void clear_client_put_message();
  static const int kClientPutMessageFieldNumber = 7;
  private:
  const ::flowmq::FlowMessage_ClientPutMessage& _internal_client_put_message() const;
  public:
  const ::flowmq::FlowMessage_ClientPutMessage& client_put_message() const;
  ::flowmq::FlowMessage_ClientPutMessage* release_client_put_message();
  ::flowmq::FlowMessage_ClientPutMessage* mutable_client_put_message();
  void set_allocated_client_put_message(::flowmq::FlowMessage_ClientPutMessage* client_put_message);

  // optional .flowmq.FlowMessage.ClientCommitMessage client_commit_message = 8;
  bool has_client_commit_message() const;
  void clear_client_commit_message();
  static const int kClientCommitMessageFieldNumber = 8;
  private:
  const ::flowmq::FlowMessage_ClientCommitMessage& _internal_client_commit_message() const;
  public:
  const ::flowmq::FlowMessage_ClientCommitMessage& client_commit_message() const;
  ::flowmq::FlowMessage_ClientCommitMessage* release_client_commit_message();
  ::flowmq::FlowMessage_ClientCommitMessage* mutable_client_commit_message();
  void set_allocated_client_commit_message(::flowmq::FlowMessage_ClientCommitMessage* client_commit_message);

  // optional .flowmq.FlowMessage.ServerSendMessage server_send_message = 9;
  bool has_server_send_message() const;
  void clear_server_send_message();
  static const int kServerSendMessageFieldNumber = 9;
  private:
  const ::flowmq::FlowMessage_ServerSendMessage& _internal_server_send_message() const;
  public:
  const ::flowmq::FlowMessage_ServerSendMessage& server_send_message() const;
  ::flowmq::FlowMessage_ServerSendMessage* release_server_send_message();
  ::flowmq::FlowMessage_ServerSendMessage* mutable_server_send_message();
  void set_allocated_server_send_message(::flowmq::FlowMessage_ServerSendMessage* server_send_message);

  // optional .flowmq.FlowMessage.ClientOpenQueue client_open_queue = 10;
  bool has_client_open_queue() const;
  void clear_client_open_queue();
  static const int kClientOpenQueueFieldNumber = 10;
  private:
  const ::flowmq::FlowMessage_ClientOpenQueue& _internal_client_open_queue() const;
  public:
  const ::flowmq::FlowMessage_ClientOpenQueue& client_open_queue() const;
  ::flowmq::FlowMessage_ClientOpenQueue* release_client_open_queue();
  ::flowmq::FlowMessage_ClientOpenQueue* mutable_client_open_queue();
  void set_allocated_client_open_queue(::flowmq::FlowMessage_ClientOpenQueue* client_open_queue);

  // optional .flowmq.FlowMessage.ConsumerDisconnected consumer_disconnected = 11;
  bool has_consumer_disconnected() const;
  void clear_consumer_disconnected();
  static const int kConsumerDisconnectedFieldNumber = 11;
  private:
  const ::flowmq::FlowMessage_ConsumerDisconnected& _internal_consumer_disconnected() const;
  public:
  const ::flowmq::FlowMessage_ConsumerDisconnected& consumer_disconnected() const;
  ::flowmq::FlowMessage_ConsumerDisconnected* release_consumer_disconnected();
  ::flowmq::FlowMessage_ConsumerDisconnected* mutable_consumer_disconnected();
  void set_allocated_consumer_disconnected(::flowmq::FlowMessage_ConsumerDisconnected* consumer_disconnected);

  // optional .flowmq.FlowMessage.ClientOpenQueueResponse client_open_queue_response = 12;
  bool has_client_open_queue_response() const;
  void clear_client_open_queue_response();
  static const int kClientOpenQueueResponseFieldNumber = 12;
  private:
  const ::flowmq::FlowMessage_ClientOpenQueueResponse& _internal_client_open_queue_response() const;
  public:
  const ::flowmq::FlowMessage_ClientOpenQueueResponse& client_open_queue_response() const;
  ::flowmq::FlowMessage_ClientOpenQueueResponse* release_client_open_queue_response();
  ::flowmq::FlowMessage_ClientOpenQueueResponse* mutable_client_open_queue_response();
  void set_allocated_client_open_queue_response(::flowmq::FlowMessage_ClientOpenQueueResponse* client_open_queue_response);

  // optional .flowmq.FlowMessage.ClientPutMessageResponse client_put_message_response = 13;
  bool has_client_put_message_response() const;
  void clear_client_put_message_response();
  static const int kClientPutMessageResponseFieldNumber = 13;
  private:
  const ::flowmq::FlowMessage_ClientPutMessageResponse& _internal_client_put_message_response() const;
  public:
  const ::flowmq::FlowMessage_ClientPutMessageResponse& client_put_message_response() const;
  ::flowmq::FlowMessage_ClientPutMessageResponse* release_client_put_message_response();
  ::flowmq::FlowMessage_ClientPutMessageResponse* mutable_client_put_message_response();
  void set_allocated_client_put_message_response(::flowmq::FlowMessage_ClientPutMessageResponse* client_put_message_response);

  // optional int64 partition_id = 2;
  bool has_partition_id() const;
  void clear_partition_id();
  static const int kPartitionIdFieldNumber = 2;
  ::google::protobuf::int64 partition_id() const;
  void set_partition_id(::google::protobuf::int64 value);

  // required .flowmq.FlowMessage.MessageType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::flowmq::FlowMessage_MessageType type() const;
  void set_type(::flowmq::FlowMessage_MessageType value);

  // @@protoc_insertion_point(class_scope:flowmq.FlowMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_partition_id();
  void clear_has_partition_id();
  void set_has_request_vote_request();
  void clear_has_request_vote_request();
  void set_has_request_vote_response();
  void clear_has_request_vote_response();
  void set_has_append_entries_request();
  void clear_has_append_entries_request();
  void set_has_append_entries_response();
  void clear_has_append_entries_response();
  void set_has_client_put_message();
  void clear_has_client_put_message();
  void set_has_client_commit_message();
  void clear_has_client_commit_message();
  void set_has_server_send_message();
  void clear_has_server_send_message();
  void set_has_client_open_queue();
  void clear_has_client_open_queue();
  void set_has_consumer_disconnected();
  void clear_has_consumer_disconnected();
  void set_has_client_open_queue_response();
  void clear_has_client_open_queue_response();
  void set_has_client_put_message_response();
  void clear_has_client_put_message_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::flowmq::FlowMessage_RequestVoteRequest* request_vote_request_;
  ::flowmq::FlowMessage_RequestVoteResponse* request_vote_response_;
  ::flowmq::FlowMessage_AppendEntriesRequest* append_entries_request_;
  ::flowmq::FlowMessage_AppendEntriesResponse* append_entries_response_;
  ::flowmq::FlowMessage_ClientPutMessage* client_put_message_;
  ::flowmq::FlowMessage_ClientCommitMessage* client_commit_message_;
  ::flowmq::FlowMessage_ServerSendMessage* server_send_message_;
  ::flowmq::FlowMessage_ClientOpenQueue* client_open_queue_;
  ::flowmq::FlowMessage_ConsumerDisconnected* consumer_disconnected_;
  ::flowmq::FlowMessage_ClientOpenQueueResponse* client_open_queue_response_;
  ::flowmq::FlowMessage_ClientPutMessageResponse* client_put_message_response_;
  ::google::protobuf::int64 partition_id_;
  int type_;
  friend struct ::protobuf_flow_5fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// required int32 index = 1;
inline bool LogEntry::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEntry::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEntry::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEntry::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 LogEntry::index() const {
  // @@protoc_insertion_point(field_get:flowmq.LogEntry.index)
  return index_;
}
inline void LogEntry::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:flowmq.LogEntry.index)
}

// required int32 term = 2;
inline bool LogEntry::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEntry::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEntry::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEntry::clear_term() {
  term_ = 0;
  clear_has_term();
}
inline ::google::protobuf::int32 LogEntry::term() const {
  // @@protoc_insertion_point(field_get:flowmq.LogEntry.term)
  return term_;
}
inline void LogEntry::set_term(::google::protobuf::int32 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.LogEntry.term)
}

// required int64 message_id = 3;
inline bool LogEntry::has_message_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogEntry::set_has_message_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogEntry::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogEntry::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 LogEntry::message_id() const {
  // @@protoc_insertion_point(field_get:flowmq.LogEntry.message_id)
  return message_id_;
}
inline void LogEntry::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.LogEntry.message_id)
}

// required int32 operation = 4;
inline bool LogEntry::has_operation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogEntry::set_has_operation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogEntry::clear_has_operation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogEntry::clear_operation() {
  operation_ = 0;
  clear_has_operation();
}
inline ::google::protobuf::int32 LogEntry::operation() const {
  // @@protoc_insertion_point(field_get:flowmq.LogEntry.operation)
  return operation_;
}
inline void LogEntry::set_operation(::google::protobuf::int32 value) {
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:flowmq.LogEntry.operation)
}

// required string message = 5;
inline bool LogEntry::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntry::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntry::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntry::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& LogEntry::message() const {
  // @@protoc_insertion_point(field_get:flowmq.LogEntry.message)
  return message_.GetNoArena();
}
inline void LogEntry::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.LogEntry.message)
}
#if LANG_CXX11
inline void LogEntry::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.LogEntry.message)
}
#endif
inline void LogEntry::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.LogEntry.message)
}
inline void LogEntry::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.LogEntry.message)
}
inline ::std::string* LogEntry::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:flowmq.LogEntry.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_message() {
  // @@protoc_insertion_point(field_release:flowmq.LogEntry.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:flowmq.LogEntry.message)
}

// -------------------------------------------------------------------

// FlowMessage_RequestVoteRequest

// required int32 term = 1;
inline bool FlowMessage_RequestVoteRequest::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_RequestVoteRequest::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_RequestVoteRequest::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_RequestVoteRequest::clear_term() {
  term_ = 0;
  clear_has_term();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteRequest::term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteRequest.term)
  return term_;
}
inline void FlowMessage_RequestVoteRequest::set_term(::google::protobuf::int32 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteRequest.term)
}

// required int32 candidate_id = 2;
inline bool FlowMessage_RequestVoteRequest::has_candidate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_RequestVoteRequest::set_has_candidate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_RequestVoteRequest::clear_has_candidate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_RequestVoteRequest::clear_candidate_id() {
  candidate_id_ = 0;
  clear_has_candidate_id();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteRequest::candidate_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteRequest.candidate_id)
  return candidate_id_;
}
inline void FlowMessage_RequestVoteRequest::set_candidate_id(::google::protobuf::int32 value) {
  set_has_candidate_id();
  candidate_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteRequest.candidate_id)
}

// required int32 last_log_index = 3;
inline bool FlowMessage_RequestVoteRequest::has_last_log_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage_RequestVoteRequest::set_has_last_log_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage_RequestVoteRequest::clear_has_last_log_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage_RequestVoteRequest::clear_last_log_index() {
  last_log_index_ = 0;
  clear_has_last_log_index();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteRequest::last_log_index() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteRequest.last_log_index)
  return last_log_index_;
}
inline void FlowMessage_RequestVoteRequest::set_last_log_index(::google::protobuf::int32 value) {
  set_has_last_log_index();
  last_log_index_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteRequest.last_log_index)
}

// required int32 last_log_term = 4;
inline bool FlowMessage_RequestVoteRequest::has_last_log_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowMessage_RequestVoteRequest::set_has_last_log_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowMessage_RequestVoteRequest::clear_has_last_log_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowMessage_RequestVoteRequest::clear_last_log_term() {
  last_log_term_ = 0;
  clear_has_last_log_term();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteRequest::last_log_term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteRequest.last_log_term)
  return last_log_term_;
}
inline void FlowMessage_RequestVoteRequest::set_last_log_term(::google::protobuf::int32 value) {
  set_has_last_log_term();
  last_log_term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteRequest.last_log_term)
}

// -------------------------------------------------------------------

// FlowMessage_RequestVoteResponse

// required int32 term = 1;
inline bool FlowMessage_RequestVoteResponse::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_RequestVoteResponse::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_RequestVoteResponse::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_RequestVoteResponse::clear_term() {
  term_ = 0;
  clear_has_term();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteResponse::term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteResponse.term)
  return term_;
}
inline void FlowMessage_RequestVoteResponse::set_term(::google::protobuf::int32 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteResponse.term)
}

// required int32 vote_result_term_granted = 2;
inline bool FlowMessage_RequestVoteResponse::has_vote_result_term_granted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_RequestVoteResponse::set_has_vote_result_term_granted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_RequestVoteResponse::clear_has_vote_result_term_granted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_RequestVoteResponse::clear_vote_result_term_granted() {
  vote_result_term_granted_ = 0;
  clear_has_vote_result_term_granted();
}
inline ::google::protobuf::int32 FlowMessage_RequestVoteResponse::vote_result_term_granted() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.RequestVoteResponse.vote_result_term_granted)
  return vote_result_term_granted_;
}
inline void FlowMessage_RequestVoteResponse::set_vote_result_term_granted(::google::protobuf::int32 value) {
  set_has_vote_result_term_granted();
  vote_result_term_granted_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.RequestVoteResponse.vote_result_term_granted)
}

// -------------------------------------------------------------------

// FlowMessage_AppendEntriesRequest

// required int32 term = 1;
inline bool FlowMessage_AppendEntriesRequest::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_AppendEntriesRequest::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_AppendEntriesRequest::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_AppendEntriesRequest::clear_term() {
  term_ = 0;
  clear_has_term();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesRequest::term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.term)
  return term_;
}
inline void FlowMessage_AppendEntriesRequest::set_term(::google::protobuf::int32 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesRequest.term)
}

// required int32 leader_id = 2;
inline bool FlowMessage_AppendEntriesRequest::has_leader_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_AppendEntriesRequest::set_has_leader_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_AppendEntriesRequest::clear_has_leader_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_AppendEntriesRequest::clear_leader_id() {
  leader_id_ = 0;
  clear_has_leader_id();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesRequest::leader_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.leader_id)
  return leader_id_;
}
inline void FlowMessage_AppendEntriesRequest::set_leader_id(::google::protobuf::int32 value) {
  set_has_leader_id();
  leader_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesRequest.leader_id)
}

// required int32 prev_log_index = 3;
inline bool FlowMessage_AppendEntriesRequest::has_prev_log_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage_AppendEntriesRequest::set_has_prev_log_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage_AppendEntriesRequest::clear_has_prev_log_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage_AppendEntriesRequest::clear_prev_log_index() {
  prev_log_index_ = 0;
  clear_has_prev_log_index();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesRequest::prev_log_index() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.prev_log_index)
  return prev_log_index_;
}
inline void FlowMessage_AppendEntriesRequest::set_prev_log_index(::google::protobuf::int32 value) {
  set_has_prev_log_index();
  prev_log_index_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesRequest.prev_log_index)
}

// required int32 prev_log_term = 4;
inline bool FlowMessage_AppendEntriesRequest::has_prev_log_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowMessage_AppendEntriesRequest::set_has_prev_log_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowMessage_AppendEntriesRequest::clear_has_prev_log_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowMessage_AppendEntriesRequest::clear_prev_log_term() {
  prev_log_term_ = 0;
  clear_has_prev_log_term();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesRequest::prev_log_term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.prev_log_term)
  return prev_log_term_;
}
inline void FlowMessage_AppendEntriesRequest::set_prev_log_term(::google::protobuf::int32 value) {
  set_has_prev_log_term();
  prev_log_term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesRequest.prev_log_term)
}

// repeated .flowmq.LogEntry entries = 5;
inline int FlowMessage_AppendEntriesRequest::entries_size() const {
  return entries_.size();
}
inline void FlowMessage_AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline ::flowmq::LogEntry* FlowMessage_AppendEntriesRequest::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.AppendEntriesRequest.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flowmq::LogEntry >*
FlowMessage_AppendEntriesRequest::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:flowmq.FlowMessage.AppendEntriesRequest.entries)
  return &entries_;
}
inline const ::flowmq::LogEntry& FlowMessage_AppendEntriesRequest::entries(int index) const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.entries)
  return entries_.Get(index);
}
inline ::flowmq::LogEntry* FlowMessage_AppendEntriesRequest::add_entries() {
  // @@protoc_insertion_point(field_add:flowmq.FlowMessage.AppendEntriesRequest.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flowmq::LogEntry >&
FlowMessage_AppendEntriesRequest::entries() const {
  // @@protoc_insertion_point(field_list:flowmq.FlowMessage.AppendEntriesRequest.entries)
  return entries_;
}

// required int32 leader_commit = 6;
inline bool FlowMessage_AppendEntriesRequest::has_leader_commit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlowMessage_AppendEntriesRequest::set_has_leader_commit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlowMessage_AppendEntriesRequest::clear_has_leader_commit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlowMessage_AppendEntriesRequest::clear_leader_commit() {
  leader_commit_ = 0;
  clear_has_leader_commit();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesRequest::leader_commit() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesRequest.leader_commit)
  return leader_commit_;
}
inline void FlowMessage_AppendEntriesRequest::set_leader_commit(::google::protobuf::int32 value) {
  set_has_leader_commit();
  leader_commit_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesRequest.leader_commit)
}

// -------------------------------------------------------------------

// FlowMessage_AppendEntriesResponse

// required int32 term = 1;
inline bool FlowMessage_AppendEntriesResponse::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_AppendEntriesResponse::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_AppendEntriesResponse::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_AppendEntriesResponse::clear_term() {
  term_ = 0;
  clear_has_term();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesResponse::term() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesResponse.term)
  return term_;
}
inline void FlowMessage_AppendEntriesResponse::set_term(::google::protobuf::int32 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesResponse.term)
}

// required int32 follower_id = 2;
inline bool FlowMessage_AppendEntriesResponse::has_follower_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_AppendEntriesResponse::set_has_follower_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_AppendEntriesResponse::clear_has_follower_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_AppendEntriesResponse::clear_follower_id() {
  follower_id_ = 0;
  clear_has_follower_id();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesResponse::follower_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesResponse.follower_id)
  return follower_id_;
}
inline void FlowMessage_AppendEntriesResponse::set_follower_id(::google::protobuf::int32 value) {
  set_has_follower_id();
  follower_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesResponse.follower_id)
}

// required int32 append_result_success = 3;
inline bool FlowMessage_AppendEntriesResponse::has_append_result_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage_AppendEntriesResponse::set_has_append_result_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage_AppendEntriesResponse::clear_has_append_result_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage_AppendEntriesResponse::clear_append_result_success() {
  append_result_success_ = 0;
  clear_has_append_result_success();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesResponse::append_result_success() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesResponse.append_result_success)
  return append_result_success_;
}
inline void FlowMessage_AppendEntriesResponse::set_append_result_success(::google::protobuf::int32 value) {
  set_has_append_result_success();
  append_result_success_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesResponse.append_result_success)
}

// required int32 last_index_synced = 4;
inline bool FlowMessage_AppendEntriesResponse::has_last_index_synced() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowMessage_AppendEntriesResponse::set_has_last_index_synced() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowMessage_AppendEntriesResponse::clear_has_last_index_synced() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowMessage_AppendEntriesResponse::clear_last_index_synced() {
  last_index_synced_ = 0;
  clear_has_last_index_synced();
}
inline ::google::protobuf::int32 FlowMessage_AppendEntriesResponse::last_index_synced() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.AppendEntriesResponse.last_index_synced)
  return last_index_synced_;
}
inline void FlowMessage_AppendEntriesResponse::set_last_index_synced(::google::protobuf::int32 value) {
  set_has_last_index_synced();
  last_index_synced_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.AppendEntriesResponse.last_index_synced)
}

// -------------------------------------------------------------------

// FlowMessage_ClientPutMessage

// required string message = 1;
inline bool FlowMessage_ClientPutMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ClientPutMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ClientPutMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ClientPutMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& FlowMessage_ClientPutMessage::message() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientPutMessage.message)
  return message_.GetNoArena();
}
inline void FlowMessage_ClientPutMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientPutMessage.message)
}
#if LANG_CXX11
inline void FlowMessage_ClientPutMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientPutMessage.message)
}
#endif
inline void FlowMessage_ClientPutMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientPutMessage.message)
}
inline void FlowMessage_ClientPutMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientPutMessage.message)
}
inline ::std::string* FlowMessage_ClientPutMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientPutMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientPutMessage::release_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientPutMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientPutMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientPutMessage.message)
}

// optional int64 message_id = 2;
inline bool FlowMessage_ClientPutMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_ClientPutMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_ClientPutMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_ClientPutMessage::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 FlowMessage_ClientPutMessage::message_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientPutMessage.message_id)
  return message_id_;
}
inline void FlowMessage_ClientPutMessage::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientPutMessage.message_id)
}

// -------------------------------------------------------------------

// FlowMessage_ClientPutMessageResponse

// required int64 message_id = 1;
inline bool FlowMessage_ClientPutMessageResponse::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_ClientPutMessageResponse::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 FlowMessage_ClientPutMessageResponse::message_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientPutMessageResponse.message_id)
  return message_id_;
}
inline void FlowMessage_ClientPutMessageResponse::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientPutMessageResponse.message_id)
}

// required .flowmq.FlowMessage.Status status = 2;
inline bool FlowMessage_ClientPutMessageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage_ClientPutMessageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::flowmq::FlowMessage_Status FlowMessage_ClientPutMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientPutMessageResponse.status)
  return static_cast< ::flowmq::FlowMessage_Status >(status_);
}
inline void FlowMessage_ClientPutMessageResponse::set_status(::flowmq::FlowMessage_Status value) {
  assert(::flowmq::FlowMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientPutMessageResponse.status)
}

// required string error_message = 3;
inline bool FlowMessage_ClientPutMessageResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ClientPutMessageResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ClientPutMessageResponse::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& FlowMessage_ClientPutMessageResponse::error_message() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
  return error_message_.GetNoArena();
}
inline void FlowMessage_ClientPutMessageResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
}
#if LANG_CXX11
inline void FlowMessage_ClientPutMessageResponse::set_error_message(::std::string&& value) {
  set_has_error_message();
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
}
#endif
inline void FlowMessage_ClientPutMessageResponse::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
}
inline void FlowMessage_ClientPutMessageResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
}
inline ::std::string* FlowMessage_ClientPutMessageResponse::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientPutMessageResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
  if (!has_error_message()) {
    return NULL;
  }
  clear_has_error_message();
  return error_message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientPutMessageResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientPutMessageResponse.error_message)
}

// -------------------------------------------------------------------

// FlowMessage_ClientCommitMessage

// required int64 message_id = 1;
inline bool FlowMessage_ClientCommitMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ClientCommitMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ClientCommitMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ClientCommitMessage::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 FlowMessage_ClientCommitMessage::message_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientCommitMessage.message_id)
  return message_id_;
}
inline void FlowMessage_ClientCommitMessage::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientCommitMessage.message_id)
}

// -------------------------------------------------------------------

// FlowMessage_ServerSendMessage

// required int64 message_id = 1;
inline bool FlowMessage_ServerSendMessage::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_ServerSendMessage::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_ServerSendMessage::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_ServerSendMessage::clear_message_id() {
  message_id_ = GOOGLE_LONGLONG(0);
  clear_has_message_id();
}
inline ::google::protobuf::int64 FlowMessage_ServerSendMessage::message_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ServerSendMessage.message_id)
  return message_id_;
}
inline void FlowMessage_ServerSendMessage::set_message_id(::google::protobuf::int64 value) {
  set_has_message_id();
  message_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ServerSendMessage.message_id)
}

// required string message = 2;
inline bool FlowMessage_ServerSendMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ServerSendMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ServerSendMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ServerSendMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& FlowMessage_ServerSendMessage::message() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ServerSendMessage.message)
  return message_.GetNoArena();
}
inline void FlowMessage_ServerSendMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ServerSendMessage.message)
}
#if LANG_CXX11
inline void FlowMessage_ServerSendMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ServerSendMessage.message)
}
#endif
inline void FlowMessage_ServerSendMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ServerSendMessage.message)
}
inline void FlowMessage_ServerSendMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ServerSendMessage.message)
}
inline ::std::string* FlowMessage_ServerSendMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ServerSendMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ServerSendMessage::release_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ServerSendMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ServerSendMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ServerSendMessage.message)
}

// -------------------------------------------------------------------

// FlowMessage_ClientOpenQueue

// required int32 open_mode = 1;
inline bool FlowMessage_ClientOpenQueue::has_open_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_ClientOpenQueue::set_has_open_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_ClientOpenQueue::clear_has_open_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_ClientOpenQueue::clear_open_mode() {
  open_mode_ = 0;
  clear_has_open_mode();
}
inline ::google::protobuf::int32 FlowMessage_ClientOpenQueue::open_mode() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueue.open_mode)
  return open_mode_;
}
inline void FlowMessage_ClientOpenQueue::set_open_mode(::google::protobuf::int32 value) {
  set_has_open_mode();
  open_mode_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueue.open_mode)
}

// required string queue_name = 2;
inline bool FlowMessage_ClientOpenQueue::has_queue_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ClientOpenQueue::set_has_queue_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ClientOpenQueue::clear_has_queue_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ClientOpenQueue::clear_queue_name() {
  queue_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_queue_name();
}
inline const ::std::string& FlowMessage_ClientOpenQueue::queue_name() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueue.queue_name)
  return queue_name_.GetNoArena();
}
inline void FlowMessage_ClientOpenQueue::set_queue_name(const ::std::string& value) {
  set_has_queue_name();
  queue_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueue.queue_name)
}
#if LANG_CXX11
inline void FlowMessage_ClientOpenQueue::set_queue_name(::std::string&& value) {
  set_has_queue_name();
  queue_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientOpenQueue.queue_name)
}
#endif
inline void FlowMessage_ClientOpenQueue::set_queue_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_queue_name();
  queue_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientOpenQueue.queue_name)
}
inline void FlowMessage_ClientOpenQueue::set_queue_name(const char* value, size_t size) {
  set_has_queue_name();
  queue_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientOpenQueue.queue_name)
}
inline ::std::string* FlowMessage_ClientOpenQueue::mutable_queue_name() {
  set_has_queue_name();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientOpenQueue.queue_name)
  return queue_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientOpenQueue::release_queue_name() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientOpenQueue.queue_name)
  if (!has_queue_name()) {
    return NULL;
  }
  clear_has_queue_name();
  return queue_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientOpenQueue::set_allocated_queue_name(::std::string* queue_name) {
  if (queue_name != NULL) {
    set_has_queue_name();
  } else {
    clear_has_queue_name();
  }
  queue_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), queue_name);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientOpenQueue.queue_name)
}

// -------------------------------------------------------------------

// FlowMessage_ClientOpenQueueResponse

// required .flowmq.FlowMessage.Status status = 1;
inline bool FlowMessage_ClientOpenQueueResponse::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowMessage_ClientOpenQueueResponse::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::flowmq::FlowMessage_Status FlowMessage_ClientOpenQueueResponse::status() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueueResponse.status)
  return static_cast< ::flowmq::FlowMessage_Status >(status_);
}
inline void FlowMessage_ClientOpenQueueResponse::set_status(::flowmq::FlowMessage_Status value) {
  assert(::flowmq::FlowMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueueResponse.status)
}

// required string error_message = 2;
inline bool FlowMessage_ClientOpenQueueResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ClientOpenQueueResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& FlowMessage_ClientOpenQueueResponse::error_message() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
  return error_message_.GetNoArena();
}
inline void FlowMessage_ClientOpenQueueResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
}
#if LANG_CXX11
inline void FlowMessage_ClientOpenQueueResponse::set_error_message(::std::string&& value) {
  set_has_error_message();
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
}
#endif
inline void FlowMessage_ClientOpenQueueResponse::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
}
inline void FlowMessage_ClientOpenQueueResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
  if (!has_error_message()) {
    return NULL;
  }
  clear_has_error_message();
  return error_message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientOpenQueueResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientOpenQueueResponse.error_message)
}

// optional string leader_ip = 3;
inline bool FlowMessage_ClientOpenQueueResponse::has_leader_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage_ClientOpenQueueResponse::set_has_leader_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_has_leader_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_leader_ip() {
  leader_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_leader_ip();
}
inline const ::std::string& FlowMessage_ClientOpenQueueResponse::leader_ip() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
  return leader_ip_.GetNoArena();
}
inline void FlowMessage_ClientOpenQueueResponse::set_leader_ip(const ::std::string& value) {
  set_has_leader_ip();
  leader_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
}
#if LANG_CXX11
inline void FlowMessage_ClientOpenQueueResponse::set_leader_ip(::std::string&& value) {
  set_has_leader_ip();
  leader_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
}
#endif
inline void FlowMessage_ClientOpenQueueResponse::set_leader_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_leader_ip();
  leader_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
}
inline void FlowMessage_ClientOpenQueueResponse::set_leader_ip(const char* value, size_t size) {
  set_has_leader_ip();
  leader_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::mutable_leader_ip() {
  set_has_leader_ip();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
  return leader_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::release_leader_ip() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
  if (!has_leader_ip()) {
    return NULL;
  }
  clear_has_leader_ip();
  return leader_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientOpenQueueResponse::set_allocated_leader_ip(::std::string* leader_ip) {
  if (leader_ip != NULL) {
    set_has_leader_ip();
  } else {
    clear_has_leader_ip();
  }
  leader_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leader_ip);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientOpenQueueResponse.leader_ip)
}

// optional string leader_port = 4;
inline bool FlowMessage_ClientOpenQueueResponse::has_leader_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage_ClientOpenQueueResponse::set_has_leader_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_has_leader_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage_ClientOpenQueueResponse::clear_leader_port() {
  leader_port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_leader_port();
}
inline const ::std::string& FlowMessage_ClientOpenQueueResponse::leader_port() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
  return leader_port_.GetNoArena();
}
inline void FlowMessage_ClientOpenQueueResponse::set_leader_port(const ::std::string& value) {
  set_has_leader_port();
  leader_port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
}
#if LANG_CXX11
inline void FlowMessage_ClientOpenQueueResponse::set_leader_port(::std::string&& value) {
  set_has_leader_port();
  leader_port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
}
#endif
inline void FlowMessage_ClientOpenQueueResponse::set_leader_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_leader_port();
  leader_port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
}
inline void FlowMessage_ClientOpenQueueResponse::set_leader_port(const char* value, size_t size) {
  set_has_leader_port();
  leader_port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::mutable_leader_port() {
  set_has_leader_port();
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
  return leader_port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FlowMessage_ClientOpenQueueResponse::release_leader_port() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
  if (!has_leader_port()) {
    return NULL;
  }
  clear_has_leader_port();
  return leader_port_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FlowMessage_ClientOpenQueueResponse::set_allocated_leader_port(::std::string* leader_port) {
  if (leader_port != NULL) {
    set_has_leader_port();
  } else {
    clear_has_leader_port();
  }
  leader_port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leader_port);
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.ClientOpenQueueResponse.leader_port)
}

// -------------------------------------------------------------------

// FlowMessage_ConsumerDisconnected

// required int32 client_id = 1;
inline bool FlowMessage_ConsumerDisconnected::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage_ConsumerDisconnected::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage_ConsumerDisconnected::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage_ConsumerDisconnected::clear_client_id() {
  client_id_ = 0;
  clear_has_client_id();
}
inline ::google::protobuf::int32 FlowMessage_ConsumerDisconnected::client_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.ConsumerDisconnected.client_id)
  return client_id_;
}
inline void FlowMessage_ConsumerDisconnected::set_client_id(::google::protobuf::int32 value) {
  set_has_client_id();
  client_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.ConsumerDisconnected.client_id)
}

// -------------------------------------------------------------------

// FlowMessage

// required .flowmq.FlowMessage.MessageType type = 1;
inline bool FlowMessage::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FlowMessage::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FlowMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FlowMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::flowmq::FlowMessage_MessageType FlowMessage::type() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.type)
  return static_cast< ::flowmq::FlowMessage_MessageType >(type_);
}
inline void FlowMessage::set_type(::flowmq::FlowMessage_MessageType value) {
  assert(::flowmq::FlowMessage_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.type)
}

// optional int64 partition_id = 2;
inline bool FlowMessage::has_partition_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FlowMessage::set_has_partition_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FlowMessage::clear_has_partition_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FlowMessage::clear_partition_id() {
  partition_id_ = GOOGLE_LONGLONG(0);
  clear_has_partition_id();
}
inline ::google::protobuf::int64 FlowMessage::partition_id() const {
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.partition_id)
  return partition_id_;
}
inline void FlowMessage::set_partition_id(::google::protobuf::int64 value) {
  set_has_partition_id();
  partition_id_ = value;
  // @@protoc_insertion_point(field_set:flowmq.FlowMessage.partition_id)
}

// optional .flowmq.FlowMessage.RequestVoteRequest request_vote_request = 3;
inline bool FlowMessage::has_request_vote_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowMessage::set_has_request_vote_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowMessage::clear_has_request_vote_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowMessage::clear_request_vote_request() {
  if (request_vote_request_ != NULL) request_vote_request_->Clear();
  clear_has_request_vote_request();
}
inline const ::flowmq::FlowMessage_RequestVoteRequest& FlowMessage::_internal_request_vote_request() const {
  return *request_vote_request_;
}
inline const ::flowmq::FlowMessage_RequestVoteRequest& FlowMessage::request_vote_request() const {
  const ::flowmq::FlowMessage_RequestVoteRequest* p = request_vote_request_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.request_vote_request)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_RequestVoteRequest*>(
      &::flowmq::_FlowMessage_RequestVoteRequest_default_instance_);
}
inline ::flowmq::FlowMessage_RequestVoteRequest* FlowMessage::release_request_vote_request() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.request_vote_request)
  clear_has_request_vote_request();
  ::flowmq::FlowMessage_RequestVoteRequest* temp = request_vote_request_;
  request_vote_request_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_RequestVoteRequest* FlowMessage::mutable_request_vote_request() {
  set_has_request_vote_request();
  if (request_vote_request_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_RequestVoteRequest>(GetArenaNoVirtual());
    request_vote_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.request_vote_request)
  return request_vote_request_;
}
inline void FlowMessage::set_allocated_request_vote_request(::flowmq::FlowMessage_RequestVoteRequest* request_vote_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_vote_request_;
  }
  if (request_vote_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request_vote_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request_vote_request, submessage_arena);
    }
    set_has_request_vote_request();
  } else {
    clear_has_request_vote_request();
  }
  request_vote_request_ = request_vote_request;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.request_vote_request)
}

// optional .flowmq.FlowMessage.RequestVoteResponse request_vote_response = 4;
inline bool FlowMessage::has_request_vote_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowMessage::set_has_request_vote_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowMessage::clear_has_request_vote_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowMessage::clear_request_vote_response() {
  if (request_vote_response_ != NULL) request_vote_response_->Clear();
  clear_has_request_vote_response();
}
inline const ::flowmq::FlowMessage_RequestVoteResponse& FlowMessage::_internal_request_vote_response() const {
  return *request_vote_response_;
}
inline const ::flowmq::FlowMessage_RequestVoteResponse& FlowMessage::request_vote_response() const {
  const ::flowmq::FlowMessage_RequestVoteResponse* p = request_vote_response_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.request_vote_response)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_RequestVoteResponse*>(
      &::flowmq::_FlowMessage_RequestVoteResponse_default_instance_);
}
inline ::flowmq::FlowMessage_RequestVoteResponse* FlowMessage::release_request_vote_response() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.request_vote_response)
  clear_has_request_vote_response();
  ::flowmq::FlowMessage_RequestVoteResponse* temp = request_vote_response_;
  request_vote_response_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_RequestVoteResponse* FlowMessage::mutable_request_vote_response() {
  set_has_request_vote_response();
  if (request_vote_response_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_RequestVoteResponse>(GetArenaNoVirtual());
    request_vote_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.request_vote_response)
  return request_vote_response_;
}
inline void FlowMessage::set_allocated_request_vote_response(::flowmq::FlowMessage_RequestVoteResponse* request_vote_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_vote_response_;
  }
  if (request_vote_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request_vote_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request_vote_response, submessage_arena);
    }
    set_has_request_vote_response();
  } else {
    clear_has_request_vote_response();
  }
  request_vote_response_ = request_vote_response;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.request_vote_response)
}

// optional .flowmq.FlowMessage.AppendEntriesRequest append_entries_request = 5;
inline bool FlowMessage::has_append_entries_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowMessage::set_has_append_entries_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowMessage::clear_has_append_entries_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowMessage::clear_append_entries_request() {
  if (append_entries_request_ != NULL) append_entries_request_->Clear();
  clear_has_append_entries_request();
}
inline const ::flowmq::FlowMessage_AppendEntriesRequest& FlowMessage::_internal_append_entries_request() const {
  return *append_entries_request_;
}
inline const ::flowmq::FlowMessage_AppendEntriesRequest& FlowMessage::append_entries_request() const {
  const ::flowmq::FlowMessage_AppendEntriesRequest* p = append_entries_request_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.append_entries_request)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_AppendEntriesRequest*>(
      &::flowmq::_FlowMessage_AppendEntriesRequest_default_instance_);
}
inline ::flowmq::FlowMessage_AppendEntriesRequest* FlowMessage::release_append_entries_request() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.append_entries_request)
  clear_has_append_entries_request();
  ::flowmq::FlowMessage_AppendEntriesRequest* temp = append_entries_request_;
  append_entries_request_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_AppendEntriesRequest* FlowMessage::mutable_append_entries_request() {
  set_has_append_entries_request();
  if (append_entries_request_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_AppendEntriesRequest>(GetArenaNoVirtual());
    append_entries_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.append_entries_request)
  return append_entries_request_;
}
inline void FlowMessage::set_allocated_append_entries_request(::flowmq::FlowMessage_AppendEntriesRequest* append_entries_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete append_entries_request_;
  }
  if (append_entries_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      append_entries_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, append_entries_request, submessage_arena);
    }
    set_has_append_entries_request();
  } else {
    clear_has_append_entries_request();
  }
  append_entries_request_ = append_entries_request;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.append_entries_request)
}

// optional .flowmq.FlowMessage.AppendEntriesResponse append_entries_response = 6;
inline bool FlowMessage::has_append_entries_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlowMessage::set_has_append_entries_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FlowMessage::clear_has_append_entries_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FlowMessage::clear_append_entries_response() {
  if (append_entries_response_ != NULL) append_entries_response_->Clear();
  clear_has_append_entries_response();
}
inline const ::flowmq::FlowMessage_AppendEntriesResponse& FlowMessage::_internal_append_entries_response() const {
  return *append_entries_response_;
}
inline const ::flowmq::FlowMessage_AppendEntriesResponse& FlowMessage::append_entries_response() const {
  const ::flowmq::FlowMessage_AppendEntriesResponse* p = append_entries_response_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.append_entries_response)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_AppendEntriesResponse*>(
      &::flowmq::_FlowMessage_AppendEntriesResponse_default_instance_);
}
inline ::flowmq::FlowMessage_AppendEntriesResponse* FlowMessage::release_append_entries_response() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.append_entries_response)
  clear_has_append_entries_response();
  ::flowmq::FlowMessage_AppendEntriesResponse* temp = append_entries_response_;
  append_entries_response_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_AppendEntriesResponse* FlowMessage::mutable_append_entries_response() {
  set_has_append_entries_response();
  if (append_entries_response_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_AppendEntriesResponse>(GetArenaNoVirtual());
    append_entries_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.append_entries_response)
  return append_entries_response_;
}
inline void FlowMessage::set_allocated_append_entries_response(::flowmq::FlowMessage_AppendEntriesResponse* append_entries_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete append_entries_response_;
  }
  if (append_entries_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      append_entries_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, append_entries_response, submessage_arena);
    }
    set_has_append_entries_response();
  } else {
    clear_has_append_entries_response();
  }
  append_entries_response_ = append_entries_response;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.append_entries_response)
}

// optional .flowmq.FlowMessage.ClientPutMessage client_put_message = 7;
inline bool FlowMessage::has_client_put_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlowMessage::set_has_client_put_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FlowMessage::clear_has_client_put_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FlowMessage::clear_client_put_message() {
  if (client_put_message_ != NULL) client_put_message_->Clear();
  clear_has_client_put_message();
}
inline const ::flowmq::FlowMessage_ClientPutMessage& FlowMessage::_internal_client_put_message() const {
  return *client_put_message_;
}
inline const ::flowmq::FlowMessage_ClientPutMessage& FlowMessage::client_put_message() const {
  const ::flowmq::FlowMessage_ClientPutMessage* p = client_put_message_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.client_put_message)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ClientPutMessage*>(
      &::flowmq::_FlowMessage_ClientPutMessage_default_instance_);
}
inline ::flowmq::FlowMessage_ClientPutMessage* FlowMessage::release_client_put_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.client_put_message)
  clear_has_client_put_message();
  ::flowmq::FlowMessage_ClientPutMessage* temp = client_put_message_;
  client_put_message_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ClientPutMessage* FlowMessage::mutable_client_put_message() {
  set_has_client_put_message();
  if (client_put_message_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ClientPutMessage>(GetArenaNoVirtual());
    client_put_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.client_put_message)
  return client_put_message_;
}
inline void FlowMessage::set_allocated_client_put_message(::flowmq::FlowMessage_ClientPutMessage* client_put_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_put_message_;
  }
  if (client_put_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_put_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_put_message, submessage_arena);
    }
    set_has_client_put_message();
  } else {
    clear_has_client_put_message();
  }
  client_put_message_ = client_put_message;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.client_put_message)
}

// optional .flowmq.FlowMessage.ClientCommitMessage client_commit_message = 8;
inline bool FlowMessage::has_client_commit_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FlowMessage::set_has_client_commit_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FlowMessage::clear_has_client_commit_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FlowMessage::clear_client_commit_message() {
  if (client_commit_message_ != NULL) client_commit_message_->Clear();
  clear_has_client_commit_message();
}
inline const ::flowmq::FlowMessage_ClientCommitMessage& FlowMessage::_internal_client_commit_message() const {
  return *client_commit_message_;
}
inline const ::flowmq::FlowMessage_ClientCommitMessage& FlowMessage::client_commit_message() const {
  const ::flowmq::FlowMessage_ClientCommitMessage* p = client_commit_message_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.client_commit_message)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ClientCommitMessage*>(
      &::flowmq::_FlowMessage_ClientCommitMessage_default_instance_);
}
inline ::flowmq::FlowMessage_ClientCommitMessage* FlowMessage::release_client_commit_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.client_commit_message)
  clear_has_client_commit_message();
  ::flowmq::FlowMessage_ClientCommitMessage* temp = client_commit_message_;
  client_commit_message_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ClientCommitMessage* FlowMessage::mutable_client_commit_message() {
  set_has_client_commit_message();
  if (client_commit_message_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ClientCommitMessage>(GetArenaNoVirtual());
    client_commit_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.client_commit_message)
  return client_commit_message_;
}
inline void FlowMessage::set_allocated_client_commit_message(::flowmq::FlowMessage_ClientCommitMessage* client_commit_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_commit_message_;
  }
  if (client_commit_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_commit_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_commit_message, submessage_arena);
    }
    set_has_client_commit_message();
  } else {
    clear_has_client_commit_message();
  }
  client_commit_message_ = client_commit_message;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.client_commit_message)
}

// optional .flowmq.FlowMessage.ServerSendMessage server_send_message = 9;
inline bool FlowMessage::has_server_send_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FlowMessage::set_has_server_send_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FlowMessage::clear_has_server_send_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FlowMessage::clear_server_send_message() {
  if (server_send_message_ != NULL) server_send_message_->Clear();
  clear_has_server_send_message();
}
inline const ::flowmq::FlowMessage_ServerSendMessage& FlowMessage::_internal_server_send_message() const {
  return *server_send_message_;
}
inline const ::flowmq::FlowMessage_ServerSendMessage& FlowMessage::server_send_message() const {
  const ::flowmq::FlowMessage_ServerSendMessage* p = server_send_message_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.server_send_message)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ServerSendMessage*>(
      &::flowmq::_FlowMessage_ServerSendMessage_default_instance_);
}
inline ::flowmq::FlowMessage_ServerSendMessage* FlowMessage::release_server_send_message() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.server_send_message)
  clear_has_server_send_message();
  ::flowmq::FlowMessage_ServerSendMessage* temp = server_send_message_;
  server_send_message_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ServerSendMessage* FlowMessage::mutable_server_send_message() {
  set_has_server_send_message();
  if (server_send_message_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ServerSendMessage>(GetArenaNoVirtual());
    server_send_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.server_send_message)
  return server_send_message_;
}
inline void FlowMessage::set_allocated_server_send_message(::flowmq::FlowMessage_ServerSendMessage* server_send_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_send_message_;
  }
  if (server_send_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_send_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_send_message, submessage_arena);
    }
    set_has_server_send_message();
  } else {
    clear_has_server_send_message();
  }
  server_send_message_ = server_send_message;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.server_send_message)
}

// optional .flowmq.FlowMessage.ClientOpenQueue client_open_queue = 10;
inline bool FlowMessage::has_client_open_queue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FlowMessage::set_has_client_open_queue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FlowMessage::clear_has_client_open_queue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FlowMessage::clear_client_open_queue() {
  if (client_open_queue_ != NULL) client_open_queue_->Clear();
  clear_has_client_open_queue();
}
inline const ::flowmq::FlowMessage_ClientOpenQueue& FlowMessage::_internal_client_open_queue() const {
  return *client_open_queue_;
}
inline const ::flowmq::FlowMessage_ClientOpenQueue& FlowMessage::client_open_queue() const {
  const ::flowmq::FlowMessage_ClientOpenQueue* p = client_open_queue_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.client_open_queue)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ClientOpenQueue*>(
      &::flowmq::_FlowMessage_ClientOpenQueue_default_instance_);
}
inline ::flowmq::FlowMessage_ClientOpenQueue* FlowMessage::release_client_open_queue() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.client_open_queue)
  clear_has_client_open_queue();
  ::flowmq::FlowMessage_ClientOpenQueue* temp = client_open_queue_;
  client_open_queue_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ClientOpenQueue* FlowMessage::mutable_client_open_queue() {
  set_has_client_open_queue();
  if (client_open_queue_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ClientOpenQueue>(GetArenaNoVirtual());
    client_open_queue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.client_open_queue)
  return client_open_queue_;
}
inline void FlowMessage::set_allocated_client_open_queue(::flowmq::FlowMessage_ClientOpenQueue* client_open_queue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_open_queue_;
  }
  if (client_open_queue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_open_queue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_open_queue, submessage_arena);
    }
    set_has_client_open_queue();
  } else {
    clear_has_client_open_queue();
  }
  client_open_queue_ = client_open_queue;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.client_open_queue)
}

// optional .flowmq.FlowMessage.ConsumerDisconnected consumer_disconnected = 11;
inline bool FlowMessage::has_consumer_disconnected() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FlowMessage::set_has_consumer_disconnected() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FlowMessage::clear_has_consumer_disconnected() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FlowMessage::clear_consumer_disconnected() {
  if (consumer_disconnected_ != NULL) consumer_disconnected_->Clear();
  clear_has_consumer_disconnected();
}
inline const ::flowmq::FlowMessage_ConsumerDisconnected& FlowMessage::_internal_consumer_disconnected() const {
  return *consumer_disconnected_;
}
inline const ::flowmq::FlowMessage_ConsumerDisconnected& FlowMessage::consumer_disconnected() const {
  const ::flowmq::FlowMessage_ConsumerDisconnected* p = consumer_disconnected_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.consumer_disconnected)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ConsumerDisconnected*>(
      &::flowmq::_FlowMessage_ConsumerDisconnected_default_instance_);
}
inline ::flowmq::FlowMessage_ConsumerDisconnected* FlowMessage::release_consumer_disconnected() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.consumer_disconnected)
  clear_has_consumer_disconnected();
  ::flowmq::FlowMessage_ConsumerDisconnected* temp = consumer_disconnected_;
  consumer_disconnected_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ConsumerDisconnected* FlowMessage::mutable_consumer_disconnected() {
  set_has_consumer_disconnected();
  if (consumer_disconnected_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ConsumerDisconnected>(GetArenaNoVirtual());
    consumer_disconnected_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.consumer_disconnected)
  return consumer_disconnected_;
}
inline void FlowMessage::set_allocated_consumer_disconnected(::flowmq::FlowMessage_ConsumerDisconnected* consumer_disconnected) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete consumer_disconnected_;
  }
  if (consumer_disconnected) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      consumer_disconnected = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, consumer_disconnected, submessage_arena);
    }
    set_has_consumer_disconnected();
  } else {
    clear_has_consumer_disconnected();
  }
  consumer_disconnected_ = consumer_disconnected;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.consumer_disconnected)
}

// optional .flowmq.FlowMessage.ClientOpenQueueResponse client_open_queue_response = 12;
inline bool FlowMessage::has_client_open_queue_response() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FlowMessage::set_has_client_open_queue_response() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FlowMessage::clear_has_client_open_queue_response() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FlowMessage::clear_client_open_queue_response() {
  if (client_open_queue_response_ != NULL) client_open_queue_response_->Clear();
  clear_has_client_open_queue_response();
}
inline const ::flowmq::FlowMessage_ClientOpenQueueResponse& FlowMessage::_internal_client_open_queue_response() const {
  return *client_open_queue_response_;
}
inline const ::flowmq::FlowMessage_ClientOpenQueueResponse& FlowMessage::client_open_queue_response() const {
  const ::flowmq::FlowMessage_ClientOpenQueueResponse* p = client_open_queue_response_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.client_open_queue_response)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ClientOpenQueueResponse*>(
      &::flowmq::_FlowMessage_ClientOpenQueueResponse_default_instance_);
}
inline ::flowmq::FlowMessage_ClientOpenQueueResponse* FlowMessage::release_client_open_queue_response() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.client_open_queue_response)
  clear_has_client_open_queue_response();
  ::flowmq::FlowMessage_ClientOpenQueueResponse* temp = client_open_queue_response_;
  client_open_queue_response_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ClientOpenQueueResponse* FlowMessage::mutable_client_open_queue_response() {
  set_has_client_open_queue_response();
  if (client_open_queue_response_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ClientOpenQueueResponse>(GetArenaNoVirtual());
    client_open_queue_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.client_open_queue_response)
  return client_open_queue_response_;
}
inline void FlowMessage::set_allocated_client_open_queue_response(::flowmq::FlowMessage_ClientOpenQueueResponse* client_open_queue_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_open_queue_response_;
  }
  if (client_open_queue_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_open_queue_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_open_queue_response, submessage_arena);
    }
    set_has_client_open_queue_response();
  } else {
    clear_has_client_open_queue_response();
  }
  client_open_queue_response_ = client_open_queue_response;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.client_open_queue_response)
}

// optional .flowmq.FlowMessage.ClientPutMessageResponse client_put_message_response = 13;
inline bool FlowMessage::has_client_put_message_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FlowMessage::set_has_client_put_message_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FlowMessage::clear_has_client_put_message_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FlowMessage::clear_client_put_message_response() {
  if (client_put_message_response_ != NULL) client_put_message_response_->Clear();
  clear_has_client_put_message_response();
}
inline const ::flowmq::FlowMessage_ClientPutMessageResponse& FlowMessage::_internal_client_put_message_response() const {
  return *client_put_message_response_;
}
inline const ::flowmq::FlowMessage_ClientPutMessageResponse& FlowMessage::client_put_message_response() const {
  const ::flowmq::FlowMessage_ClientPutMessageResponse* p = client_put_message_response_;
  // @@protoc_insertion_point(field_get:flowmq.FlowMessage.client_put_message_response)
  return p != NULL ? *p : *reinterpret_cast<const ::flowmq::FlowMessage_ClientPutMessageResponse*>(
      &::flowmq::_FlowMessage_ClientPutMessageResponse_default_instance_);
}
inline ::flowmq::FlowMessage_ClientPutMessageResponse* FlowMessage::release_client_put_message_response() {
  // @@protoc_insertion_point(field_release:flowmq.FlowMessage.client_put_message_response)
  clear_has_client_put_message_response();
  ::flowmq::FlowMessage_ClientPutMessageResponse* temp = client_put_message_response_;
  client_put_message_response_ = NULL;
  return temp;
}
inline ::flowmq::FlowMessage_ClientPutMessageResponse* FlowMessage::mutable_client_put_message_response() {
  set_has_client_put_message_response();
  if (client_put_message_response_ == NULL) {
    auto* p = CreateMaybeMessage<::flowmq::FlowMessage_ClientPutMessageResponse>(GetArenaNoVirtual());
    client_put_message_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flowmq.FlowMessage.client_put_message_response)
  return client_put_message_response_;
}
inline void FlowMessage::set_allocated_client_put_message_response(::flowmq::FlowMessage_ClientPutMessageResponse* client_put_message_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_put_message_response_;
  }
  if (client_put_message_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_put_message_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_put_message_response, submessage_arena);
    }
    set_has_client_put_message_response();
  } else {
    clear_has_client_put_message_response();
  }
  client_put_message_response_ = client_put_message_response;
  // @@protoc_insertion_point(field_set_allocated:flowmq.FlowMessage.client_put_message_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flowmq

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flowmq::LogEntry_OPERATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flowmq::LogEntry_OPERATION>() {
  return ::flowmq::LogEntry_OPERATION_descriptor();
}
template <> struct is_proto_enum< ::flowmq::FlowMessage_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flowmq::FlowMessage_MessageType>() {
  return ::flowmq::FlowMessage_MessageType_descriptor();
}
template <> struct is_proto_enum< ::flowmq::FlowMessage_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flowmq::FlowMessage_Status>() {
  return ::flowmq::FlowMessage_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_flow_5fmessage_2eproto
